#include<iostream>
#include <iomanip>
#include <string>
#include <vector>
#include <stack>
#include <algorithm>
using namespace std;

//Structure to hold information about each item in a receipt
struct Item {
    string name;
    double price;
    int quantity;

    //Calculate total price for this item
    double total() const {
        return price * quantity;
    }
};

struct ItemNode// Pointer of Linked-list
{
	Item *data;
	ItemNode *next;
};

//Structure to represent a receipt
struct Receipt {
    int receiptNo;
    string date;
    double grandTotal;
    vector<Item> items;
};

struct ReceiptNode //Linked-list of receipts
{
	Receipt data;
	ReceiptNode *next;
};

//Class to manage the linked list of receipts
class ReceiptList {
private:
    ReceiptNode *head;     //Pointer to the first receipt in the list
	int nextReceiptNo;
	
public:
    ReceiptList() : head(nullptr), nextReceiptNo(1) {}

	//Create receipt list
    int addReceipt(vector<Item>& items, const string &date)
	{
		Receipt newReceipt;
		newReceipt.receiptNo = nextReceiptNo++;
		newReceipt.date = date;
		newReceipt.grandTotal = 0;
	
		//Copy items into the receipt's item list
		for(const Item &item : items)
		{
			newReceipt.grandTotal += item.total();
		}
	
		ReceiptNode *newReceiptNode = new ReceiptNode;
		newReceiptNode ->data = newReceipt;
		newReceiptNode ->next = nullptr;
	
		//Add the new receipt to the list
		if (!head)
		{
			head = newReceiptNode;
		}
		else
		{
			ReceiptNode *temp = head;
			while (temp->next!=nullptr)
			{
				temp = temp->next;
			}
			temp->next = newReceiptNode;
		}
	
		return newReceipt.receiptNo;
	}
	
     //Function to display a single receipt in a formatted table
    void displayReceipt(const Receipt* r) {
        if (!r) return;
        cout << "Receipt No: " << r->receiptNo << "\nDate: " << r->date << endl;
        cout << "--------------------------------------------\n";
        cout << left << setw(5) << "No" << setw(25) << "Item Name" << setw(10) << "Price" << setw(10) << "Qty" << "Total\n";
        double grandTotal = 0;
        for (size_t i = 0; i < r->items.size(); ++i) {
            const Item& item = r->items[i];
            double total = item.total();
            cout << left << setw(5) << (i + 1) << setw(25) << item.name << setw(10) << item.price
                 << setw(10) << item.quantity << total << endl;
            grandTotal += total;    //Accumulate grand total
        }
        cout << "--------------------------------------------\n";
        cout << "TOTAL: RM " << grandTotal << "\n\n";
    }

    //Function to display all receipts in the system
    void viewAllReceipts() {
        ReceiptNode *current = head;
        while (current) {
            displayReceipt(&current->data);
            current = current->next;    //Move to the next receipt
        }
    }

    //Sequential search to find a receipt by receipt number
    void sequentialSearch(int targetReceiptNo) {
        ReceiptNode *current = head;
        while (current) {
            if (current->data.receiptNo == targetReceiptNo) {
                cout << "[Sequential Search] Receipt found:\n";
                displayReceipt(&current->data);
                return;
            }
            current = current->next;
        }
        cout << "Receipt not found with number " << targetReceiptNo << " (Sequential Search).\n";
    }    //End sequential search

    //Binary search to find a receipt by receipt number
    void binarySearch(int targetReceiptNo) {
        //Convert linked list to vector for binary search
        vector<Receipt*> receiptArray;
        ReceiptNode *current = head;
        while (current) {
            receiptArray.push_back(&current->data);
            current = current->next;
        }    //End while loop

        //Sort by receipt number
        sort(receiptArray.begin(), receiptArray.end(), [](Receipt* a, Receipt* b) {
            return a->receiptNo < b->receiptNo;
        });

        //Binary search on sorted vector
        int low = 0, high = receiptArray.size() - 1;
        while (low <= high) {
            int mid = (low + high) / 2;
            if (receiptArray[mid]->receiptNo == targetReceiptNo) {
                cout << "[Binary Search] Receipt found:\n";
                displayReceipt(receiptArray[mid]);
                return;
            } else if (receiptArray[mid]->receiptNo < targetReceiptNo) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        //If not found
        cout << "Receipt not found with number " << targetReceiptNo << " (Binary Search).\n";
    }

    //Destructor to clean up memory used by linked list
    ~ReceiptList() {
        while (head) {
            ReceiptNode *temp = head;
            head = head->next;
            delete temp;
        }
    }
};

//Function to add pre-set receipt data for testing
void createSampleReceipts(ReceiptList& list) {
   list.addReceipt(101, "29/4/2024", {
      {"C++ for Beginner", 138.0, 1},
     {"Let's Cook", 20.0, 2}
    });
    list.addReceipt(102, "29/4/2024", {
        {"Data Structures", 75.0, 3},
        {"Python Basics", 60.0, 1}
    });
    list.addReceipt(103, "29/4/2024", {
        {"Cooking 101", 25.0, 2}
    });
    list.addReceipt(104, "29/4/2024", {
        {"Java for All", 95.0, 1}
    });
    list.addReceipt(105, "29/4/2024", {
        {"Algorithms Deep Dive", 88.0, 1}
    });
}

//Main Menu Interface for Testing
int main() {
    ReceiptList list;
    createSampleReceipts(list);

    int choice, receiptNo;
    do {
        cout << "\n--- View Order Detail Menu ---\n";
        cout << "1. View All Receipts\n";
        cout << "2. Search by Receipt No (Linear Search)\n";
        cout << "3. Search by Receipt No (Binary Search)\n";
        cout << "0. Exit\n";
        cout << "Choice: ";
        cin >> choice;

        switch (choice) {
        case 1:
            list.viewAllReceipts();
            break;
        case 2:
            cout << "Enter Receipt No to search (Sequential): ";
            cin >> receiptNo;
            list.sequentialSearch(receiptNo);
            break;
        case 3:
            cout << "Enter Receipt No to search (Binary): ";
            cin >> receiptNo;
            list.binarySearch(receiptNo);
            break;
        case 0:
            cout << "Exiting...\n";
            break;
        default:
            cout << "Invalid choice.\n";
        }
    } while (choice != 0);
}

// Manage a New Sale Order 
// This function uses a stack to temporarily store an order before confirmation
void manageCurrentOrder(ReceiptList& receiptList) 
{
    stack<Item> orderStack; // Temporary container for current order
    int choice;

    do {
        cout << "\n-- Current Sale Order Menu --\n";
        cout << "1. Add Item\n";
        cout << "2. Edit Last Item\n";
        cout << "3. Delete Last Item\n";
        cout << "4. View Current Order\n";
        cout << "5. Confirm Order\n";
        cout << "0. Cancel Order\n";
        cout << "Enter your choice: ";
        cin >> choice;

        if (choice == 1) {
        	if(orderStack.size() >= 5)
        	{
        		cout<< "Maximum of 5 item per order allowed.\n";
        		continue;
			}
			
            Item item;
            cout << "Enter item name: ";
            cin.ignore();
            getline(cin, item.name);
            cout << "Enter price (RM): ";
            cin >> item.price;
            cout << "Enter quantity: ";
            cin >> item.quantity;
            orderStack.push(item); // Add to stack
        }
        else if (choice == 2) {
            if (orderStack.empty()) {
                cout << "No item to edit.\n";
                continue;
            }
            Item topItem = orderStack.top(); // Get top item
            orderStack.pop(); // Remove it to allow editing
            cout << "Editing item: " << topItem.name << "\n";
            cout << "Enter new name: ";
            cin.ignore();
            getline(cin, topItem.name);
            cout << "Enter new price (RM): ";
            cin >> topItem.price;
            cout << "Enter new quantity: ";
            cin >> topItem.quantity;
            orderStack.push(topItem); // Push back the updated item
        }
        else if (choice == 3) {
            if (!orderStack.empty()) {
                cout << "Deleted item: " << orderStack.top().name << "\n";
                orderStack.pop();
            } else {
                cout << " Stack is already empty.\n";
            }
        }
        else if (choice == 4) {
            if (orderStack.empty()) {
                cout << " Order is currently empty.\n";
                continue;
            }

            stack<Item> temp = orderStack;
            vector<Item> displayItems;

            // Reverse order for proper display
            while (!temp.empty()) {
                displayItems.push_back(temp.top());
                temp.pop();
            }
            reverse(displayItems.begin(), displayItems.end());

            cout << "\n--- Current Order ---\n";
            cout << left << setw(5) << "No" << setw(25) << "Item Name"
                 << setw(10) << "Price" << setw(10) << "Qty" << "Total\n";
            double grandTotal = 0;
            for (size_t i = 0; i < displayItems.size(); ++i) {
                Item item = displayItems[i];
                double total = item.total();
                cout << left << setw(5) << (i + 1) << setw(25) << item.name
                     << setw(10) << item.price << setw(10) << item.quantity << total << endl;
                grandTotal += total;
            }
            cout << "TOTAL: RM " << grandTotal << "\n";
        }
        else if (choice == 5) {
            if (orderStack.empty()) {
                cout << "Cannot confirm an empty order.\n";
                continue;
            }

            vector<Item> confirmedItems;
            while (!orderStack.empty()) {
                confirmedItems.push_back(orderStack.top());
                orderStack.pop();
            }
            reverse(confirmedItems.begin(), confirmedItems.end());

            string date;
            cout << "Enter date (e.g., 29/4/2024): ";
            cin.ignore();
            getline(cin, date);
            receiptList.addReceipt(confirmedItems, date);
            break;
        }

    } while (choice != 0);
}
